[toc]

# x86汇编语言-从实模式到保护模式_学习笔记

## 处理器、内存和指令

### 处理器

1. 最早的处理器是弗德里科法金设计的**Intel4004**
2. 处理器(Processor)是一台电子计算机的核心，它在振荡器脉冲的激励下，从内存中获取指令，并发起一系列由该指令所定义的操作。当操作结束后，再取下一条指令。通常情况下，这个过程是循环往复的。
3. 寄存器(Register)是为了将输入数字所表示的一组二进制电信号存储，也就是将其锁住，为了以后使用。
4. 而为了使用这些寄存器，需要由内部线路与寄存器相连，来传输所需的二进制数据，所以这些内部线路称为处理器内部总线。
5. 算术逻辑部件(ALU)是专门用来将输入的二进制数**进行所制定的操作**的部件，比如两个寄存器中的数相加，通过内部总线连接到ALU，输出相加结果，并且可以用另一个寄存器锁住输出结果。
6. 16位寄存器可以存放两个字节，连个字节称为一个字(word)。

### 内存

1. 内存和寄存器不同，内存用于保存更多的比特。
2. 单次访问的内存的最小单位是1字节，每个字节对应一个地址
3. 为了访问内存，处理器需要给出内存的地址，以及指明是写操作还是读操作。
4. 虽然**不同位**的处理器包含**不同位**的寄存器和算术逻辑单元，例如8位处理器有**8位**的寄存器和算术逻辑部件，16位拥有**16位**的寄存器和算术逻辑单元，同理64位处理器。
5. 虽然内存的最小单位是字节，但是通过安排，还是可以**单次访问**就能处理8位(**字节**)，16位(**字**)，32位(**双字**)或64位(**四字**)的二进制数。注意：**不是一个一个**地取出每个字节，然后组合。
6. 处理器会发出字长控制信号，用于指示本次访问的字长是8、16、32和64。例如给出地址是0x0002H，要看字长控制信号是什么，如果是8，则只影响到单个字节，若给出16，则会影响到内存的一个字，但地址仍然是0x0002H。实际上地址给出的是字中的低八位的地址，我称为数据的首地址，其次高八位藏在0x0003H，但是称这个字的地址是一开始的地址，也就是0x0002H。

### 指令和指令集

1. 概念：处理器的设计者用某一些数来指示处理器所做的操作，称为指令(Instruction)。或者称其为机器指令。
2. **指令是存放在内存里的**，一条接一条，处理器的工作是自动按顺序取出，并加以执行。
3. 内存地址的最低端(0x0000H，举个例子)。
4. 指令一般是由操作码和操作数构成，但也有一小部分仅仅含有操作码，不含有操作数，就像处理器停机指令(F4H)。指令其长度不定，短的1个字节，长至15字节。
5. 指令的操作码表示了如何执行该指令的信息，做什么干什么
6. 立即数是指在指令当中直接可以获得的操作数，称为立即数。如果立即数是内存地址，还要通过内存地址的访问获得数据，那就不叫立即数。
7. 指令和非指令的普通二进制数是一模一样的，都是由高低电平组成的。所以指令中不能含有非指令的数据，所以指令和数据分别位于内存的不同区域。
8. 存放指令的区域叫代码区，存放数据的区域叫数据去。
9. 每个处理器能够识别的指令是有限的，**指令的集合称为该处理器的指令集**。

### 古老的8086处理器

1. 8086是Intel第一款16位处理器，诞生于1978。
2. 8086的通用寄存器
   1. 拥有8个16位的**通用**寄存器，分别命名为AX、BX、CX、DX、SI、DI、BP、SP。通用即为可用于多种目的。
   2. 其中AX、BX、CX、DX，有可以分开拆成两个8位的寄存器来使用。例如AX可以拆成高八位AH，和第八位AL，同理其他。
3. 程序的重定位难题
   1. 概括一句话，程序和数据分段。
4. 内存分段机制
   1. 内存空间就如同很长的纸条，在内存中分段，就像从长纸条中裁剪下一小段，来单独使用。
   2. 就比如内存地址A532H一样，将其剪下，其中包括了6个内存单元，分别是A532H、A533H、A534H、A535H、A536H、A537H。
   3. 但是若采用分段机制，每一段可以单独打出来分为**段地址**和**偏移地址**就很方便了。
   4. 那么如何表示A532H呢，A532H:0000H，因为段在任何地方可以裁剪，长度最长就是原来的长纸条。
   5. 所以可以用 **"段:偏移"** 表示。
   6. 在执行程序的过程中，处理器访问内存时，他把指令中指定的内存地址看成是**段内的偏移地址**，而不是物理地址。实际上处理器会将**段地址和指令中提供的偏移地址所相加**，来获取访问内存所需要的物理地址。
   7. 为了在硬件层面提供对段偏移内存访问模式的支持，处理器至少提供两个段寄存器，分别是**代码段(Code Segment, CS)寄存器**和**数据段(Data Segment, DS)**寄存器。
   8. 所以当下一次执行这个程序时，代码段和数据段在内存中的位置发生变化，但只要把**分配好的代码段和数据段地址传送到CS和DS中**，程序依靠的偏移地址也能被正确执行。
5. 8086内存分段机制